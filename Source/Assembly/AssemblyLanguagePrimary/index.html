<!-- build time:Sun Jan 08 2023 00:51:49 GMT+0800 (香港标准时间) --><!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="打爆你滴脑阔" href="https://xiaoliangcoder.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="打爆你滴脑阔" href="https://xiaoliangcoder.github.io/atom.xml"><link rel="alternate" type="application/json" title="打爆你滴脑阔" href="https://xiaoliangcoder.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="Assembly Language"><link rel="canonical" href="https://xiaoliangcoder.github.io/Source/Assembly/AssemblyLanguagePrimary/"><title>C++反汇编语言 - 入门 - AssemblyLanguagePrimary - Assembly | Senior Brother = 打爆你滴脑阔 = 笔记</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">C++反汇编语言 - 入门</h1><div class="meta"><span class="item" title="作成日：2022-10-16 15:52:04"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">投稿日</span> <time itemprop="dateCreated datePublished" datetime="2022-10-16T15:52:04+08:00">2022-10-16</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="ナビゲーションバーの切り替え"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Senior Brother</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://api.ixiaowai.cn/gqapi/gqapi2.php"></li><li class="item" data-background-image="https://api.likepoems.com/img/aliyun/pc"></li><li class="item" data-background-image="https://api.yimian.xyz/img"></li><li class="item" data-background-image="https://api.dujin.org/pic/yuanshen/"></li><li class="item" data-background-image="https://api.r10086.com/img-api.php?type=动漫综合2"></li><li class="item" data-background-image="https://api.r10086.com/img-api.php?type=动漫综合3"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">ホーム</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Assembly/" itemprop="item" rel="index" title="カテゴリ Assembly"><span itemprop="name">Assembly</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Assembly/AssemblyLanguagePrimary/" itemprop="item" rel="index" title="カテゴリ AssemblyLanguagePrimary"><span itemprop="name">AssemblyLanguagePrimary</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-Hans"><link itemprop="mainEntityOfPage" href="https://xiaoliangcoder.github.io/Source/Assembly/AssemblyLanguagePrimary/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="XiaoLiang"><meta itemprop="description" content="笔记, 黑不溜qiu的抠脚大汉"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="打爆你滴脑阔"></span><div class="body md" itemprop="articleBody"><h1 id="一-简介"><a class="anchor" href="#一-简介">#</a> 一、简介</h1><ul><li>代码运行环境：VS2019、 x64 位、debug 模式。</li><li>CPU：AMD</li><li><a href="https://xiaoliangcoder.github.io/Source/Assembly/AssemblyLanguageBase/">汇编语言基础</a></li></ul><h1 id="二-基础"><a class="anchor" href="#二-基础">#</a> 二、基础</h1><h2 id="1-定义数据"><a class="anchor" href="#1-定义数据">#</a>   1. 定义数据</h2><ul><li>C++：在 C++ 中可以用 bool、short、int、float、char、double 等基础类型定义数据，那么它们在汇编语言中是如何表现的呢？</li><li>汇编语言<strong>定义数据</strong>：<ul><li>单位：byte（1 字节）、word（1 字、2 字节）、double word（双字、4 字节）、quad word（4 字、8 字节）。</li><li>定义数据（伪指令）：<ul><li>db：define byte，定义操作数占用 1 字节大小。</li><li>DW 定义操作数占用两字节大小，DD 定义操作数占用四个字节、DQ 定义操作数占用八个字节。</li><li>例如：<ul><li>dw 0123h, 0456h, 0789h, 0abch -&gt; 定义了 4 个数据，每个数据占用 2 个字节，一共占用 8 个字节。</li><li>db 'Hello' -&gt; 字符串应该拆开来看，所以定义 hello<strong> 每个字符</strong>占用<strong> 1 字节大小</strong>，一共占用 5 字节大小。</li></ul></li></ul></li></ul></li><li>C++ 定义的基本数据类型 =》反汇编 =》汇编语言申明<strong>内存大小</strong><ul><li>用 byte、word、dword、qword 等，放在地址前用来定义操作内存的大小。</li><li>8 位 / 16 位 / 32 位 / 64 位的寄存器，代表不同大小。注：32 位寄存器多用 E 开头，64 位寄存器多用 R 开头。</li><li>例子：<pre><code class="language-C++">    bool b = true;
        mov         byte ptr [rbp+4],1          \\\ rbp存放的是栈底地址，所以这里在栈上分配了一个字节大小空间[rbp+4]到[rbp+5]，存储bool类型的值，并赋初值。
    int i = 1;
        mov         dword ptr [rbp+24h],1       \\\ 同理，注意有h的代表十六进制数，没有h代表十进制数！
    float f = 1.2;
        movss       xmm0,dword ptr [00007FF75A089BB0h]  \\\ xmm0是浮点数的寄存器，浮点数的计算方法比较特殊。
        movss       dword ptr [rbp+44h],xmm0    \\\ 先将浮点数移入xmm0中，然后在放入栈上（rbp+44h - rbp+4ch)。
    char c = 'a';
        mov         byte ptr [rbp+64h],61h      \\\ 字符串都会翻译成二进制编码（如：ASCII、UTF-8、GB2312等），存储在内存中！
</code></pre></li></ul></li><li>总结<ul><li>C++ 是强类型数据语言，所有的数据都必须定义类型，类型用于在 C++ 编译器中解释该类型的<strong>数据大小</strong>！从而将 C++ 数据转为汇编语言的数据。<ul><li>.cpp -&gt; C++ 编译器 -&gt; 汇编语言 -&gt; 汇编编译器 -&gt; 二进制语言</li><li>C++ 的数据类型更符合人类的认知。</li></ul></li><li>汇编语言数据的定义更符合计算机的工作。对于汇编语言来讲，数据都是二进制类型（计算机只能存储二进制数据），所以只关心数据长度或大小（类型相同：二进制 0 和 1）！<br>至于数据怎么使用（相加、相减、字符合并，输出等等）都交给程序员决定，有点弱数据类型语言的味道！</li></ul></li></ul><h2 id="2-汇编语言-段伪指令"><a class="anchor" href="#2-汇编语言-段伪指令">#</a>   2. 汇编语言 - 段（伪指令）</h2><ul><li>汇编语言有数据和代码，数据又可以根据需求不同继续细分（栈数据、堆数据、全局数据...），代码又可以根据功能不同继续细分，<br>那么汇编语言如何解决程序越来越复杂时，将不同的数据、代码拆分开来！</li><li>Segment (段)，顾名思义就是将数据、程序根据需求一段一段的拆分出来！</li><li>定义段：<ul><li>用伪指令 assume 定义段，后面直接跟段名。</li><li>定义三个段，分别为代码段、数据段、栈段：assume cs:code, ds:data, ss:stack，var<ul><li>cs:ip 是代码指针寄存器，它们指向何处就该何处的代码执行。cs 是段寄存器，RIP 是偏移地址寄存器（段 + 偏移的逻辑地址算法）。</li><li>ds:bx,ss:sp 分别是数据段和栈段指针寄存器，它们指向何处何处就是数据段和栈空间。</li><li>assume cs:code 表示定义段 code，并将 cs:ip 指针指向段开始的地址。当然也可以像 var 那样，只定义段。</li></ul></li></ul></li><li>使用段 =》8086 机汇编代码示例：</li></ul><pre><code class="language-C++">    ;代码功能：将data段中的数据依次入栈到stack栈段，然后stack栈段又依次出栈到data。

    assume cs:code, ds:data, ss:stack
    data segment                ;段开始
        dw 0123h, 0456h, 0789h, 0abch, 0123h, 0456h, 0789h, 0abch
    data ends                   ;段结束

    stack segment
        dw 16 dup (0)           ;用dup定义16个dw数据，初始化为0
    stack ends

    code segment
    start: mov ax,stack         ;将stack段首地址放入ax中
           mov ss,ax            ;用ss指向stack，其实就是上面的SS:stack，只是这里演示用程序动态指向stack。
           mov sp,20h           ;设置栈顶ss:sp指向stack:20
           
           mov ax,data
           mov ds,ax            ;同上，ds指向data段

           mov bx,0             ;ds:bx指向data段中的第一个单元

           mov cx,8             ;cx是循环计数器
    s:     push [bx]
           add bx,2
           loop s               ;将data段中的0~15单元中的数据依次入栈

           mov bx,0
           
           mov cx,8
   s0：    pop [bx]
           add bx,2
           loop s0              ;以此出栈数据到data段中的0~15单元中

           mov ax,4c00h         ;返回上一级的代码
           int 21h
    code ends                   ; code段结束
    end start                   ; start结束



;注：start就是一个标号,标志程序的入口而已,程序加载到内存之后CS:IP会指向这个标号,从start指向的指令开始运行
;这个标号不一定是start,你也可以用main,但在程序的最后要用end main来提示程序结束
;start也不一定在代码段的最前面,它的前面是可以有指令或数据的。
</code></pre><ul><li>常见的数据段<ul><li>BSS 段: BSS 段。用来存放程序中<strong>未初始化或初始化为 0 的全局变量</strong>的一块内存区域。BSS 是英文 BlockStarted by Symbol 的简称，BSS 段属于静态内存分配。</li><li>DATA 段：数据段。用来存放程序中<strong>已初始化的全局变量</strong>的一块内存区域。数据段属于静态内存分配。</li><li>TEXT 段：代码段。用来存放程序<strong>执行代码</strong>的一块内存区域，只读属性。</li><li>CONST 段：常量段。用来存放程序中<strong>常量数据</strong>的一块内存区域，只读属性。</li></ul></li></ul><h2 id="3-vs反汇编"><a class="anchor" href="#3-vs反汇编">#</a>   3. VS 反汇编</h2><ul><li>VS 的调试窗口下，有寄存器、内存、汇编代码、Watch 等窗口可以查看跟踪程序汇编代码。</li><li>输出汇编代码：项目 -&gt; 属性 -&gt;C/C++-&gt; 输出文件 -&gt; 汇编程序输出 -&gt; 程序集、机器码和源码<ul><li>输出文件 /x64/Debug/YourCppName.cod 或者 YourCppName.asm</li></ul></li></ul><h1 id="三-常量和变量"><a class="anchor" href="#三-常量和变量">#</a> 三、常量和变量</h1><h2 id="1-常量和变量简述"><a class="anchor" href="#1-常量和变量简述">#</a>   1. 常量和变量简述</h2><ul><li>C++：栈区、堆区、全局区、常量区、代码区等</li><li>汇编语言：常量段、数据段、栈段、堆段、代码段等</li><li>二进制语言：内存地址 + 属性<ul><li>属性：可读、可写、可执行</li><li>变量（可读写）、常量（可读）、代码（可执行）</li></ul></li></ul><h2 id="2-宏"><a class="anchor" href="#2-宏">#</a>   2. 宏</h2><ul><li>宏会被 C++ 编译器<strong>直接替换</strong>目标代码！</li></ul><pre><code class="language-C++">    #define TEST_MACRO_NUM 10
    #define TEST_MACRO_Add(a,b) a+b
    #define TEST_MACRO_SQRT(c) sqrt(c)

    int main(int argc, char* argv[])
    &#123;
        /// ...
	        printf(&quot;%d\n&quot;, TEST_MACRO_NUM);
        mov         edx,0Ah                    /// TEST_MACRO_NUM被直接替换成立即数10=0Ah
        lea         rcx,[string &quot;%d\n&quot;]
        call        printf                     /// 调用Print函数
	        printf(&quot;%d\n&quot;, TEST_MACRO_Add(1, 2));
        mov         edx,3                      /// 编译器优化1+2=3（能直接计算或能简化都会被编译器优化）
        lea         rcx,[string &quot;%d\n&quot;]  
        call        printf  
	        printf(&quot;%d\n&quot;, TEST_MACRO_SQRT(3));
        mov         ecx,3                          /// 将参数3传给寄存器ecx
        call        sqrt&lt;int,0&gt;                    /// 调用sqrt函数，参数为ecx /// sqrt模板类根据类型展开
        movaps      xmm1,xmm0  
        movq        rdx,xmm1  
        lea         rcx,[string &quot;%d\n&quot;]  
        call        printf 
	        return 0;
        xor         eax,eax 
    &#125;

</code></pre><h2 id="3-const常量"><a class="anchor" href="#3-const常量">#</a>   3. const 常量</h2><ul><li>在所有直接使用 const 的常量的地方，C++ 编译器会在<strong>编译期间</strong>直接替换成常量或立即数。</li><li>但实质还是个变量，占用内存，可以被<strong>强制</strong>修改其内存的值！</li></ul><pre><code class="language-C++">    int main(int argc, char* argv[])
    &#123;
        /// ...
    	        const int iVar = 1;
        mov         dword ptr [rbp+4],1  /// 在栈上分配了内存，首地址是[rbp+4]，大小为dword
	        printf(&quot;%d\n&quot;, iVar);
        mov         edx,1              /// 直接替换成立即数
        lea         rcx,[string &quot;%d\n&quot;]  
        call        printf  

	        int* pVar = (int*)&amp;iVar;            /// 强转去掉const属性，然后将用指针指向const变量的内存
        lea         rax,[rbp+4]  
        mov         qword ptr [rbp+28h],rax  
	        ++(*pVar);                          /// +1
        mov         rax,qword ptr [rbp+28h]  
        mov         eax,dword ptr [rax]  
        inc         eax  
        mov         rcx,qword ptr [rbp+28h]  
        mov         dword ptr [rcx],eax  
	        printf(&quot;%d\n&quot;, iVar);
        mov         edx,1              /// 直接替换成立即数
        lea         rcx,[string &quot;%d\n&quot;] 
        call        printf  
	        printf(&quot;%d\n&quot;, *pVar);              /// 输出const变量内存的值
        mov         rax,qword ptr [rbp+28h]  
        mov         edx,dword ptr [rax]  
        lea         rcx,[string &quot;%d\n&quot;]  
        call        printf  
	        return 0;
        xor         eax,eax 
    &#125;

输出结果：1、1、2
</code></pre><ul><li>#define 和 const 常量<ul><li>#define 真常量，编译期间就会被替换，宏符号名称不会出现在执行文件中！</li><li>const “假” 常量，只是编译期间对语法进行了检查，并在编译期间直接替换使用 const 常量的地方，但实质还是个变量。</li><li>都是 C++ 语法，汇编语言（只有 CONST 段及只读区域）和二进制编码中没有这两种类型的存在。</li></ul></li></ul><h2 id="3-常量总结"><a class="anchor" href="#3-常量总结">#</a>   3. 常量总结</h2><ul><li>常量基础<ul><li>字面意思：常量是一个恒定不变的值，它在内存中是不可被修改的！</li><li>程序中的 1、2、3 等数字或者 &quot;Hello World!&quot; 这样的字符，以及数组名称都属于常量，它们在运行时不能被修改。</li><li><strong>常量在程序运行前就已经存在，它们被编译进可执行文件中！</strong><ul><li>立即数常量被直接写进代码中。</li><li>常量数据区，该区域程序没有写的权限。</li><li>代码区，如数组名称，this，函数名和函数参数名等等。（看汇编代码像是这样，仅表示个人看法）</li></ul></li></ul></li><li>常量测试<ul><li>C++ 代码<pre><code class="language-C++">int main(int argc, char* argv[])
&#123;
    printf(&quot;Hello Wolrd!\n&quot;);
    string s = &quot;I am string&quot;;
    int intArray[3] = &#123; 1,2,3 &#125;;

    const int iVar = 1;
    printf(&quot;%d\n&quot;, iVar);
#define IVAR 2
    printf(&quot;%d\n&quot;, iVar);

    return 0;
&#125;
</code></pre><ul><li>汇编代码（VS 生成的.asm 文件）</li></ul><pre><code class="language-C++">/// 汇编语言中&quot;;&quot;表示后面是注释
//////////////////////////// 常量数据区（CONST 段） ////////////////////////////

/// print中的 %d 字符
CONST	SEGMENT
??_C@_03PMGGPEJJ@?$CFd?6@ DB '%d', 0aH, 00H		; `string'
CONST	ENDS

/// 字符 I am string
CONST	SEGMENT
??_C@_0M@CFPJMFMA@I?5am?5string@ DB 'I am string', 00H	; `string'
CONST	ENDS

/// 字符 Hello Wolrd!
CONST	SEGMENT
??_C@_0O@DDOOOAMO@Hello?5Wolrd?$CB?6@ DB 'Hello Wolrd!', 0aH, 00H ; `string'
CONST	ENDS

//////////////////////////// 代码区 ////////////////////////////
/// 数组名字，intArray$ = 72，表示偏移72个内存单元
/// 例如：intArray$[rbp]，表示距离栈底地址[rbp]偏移72，运行时的汇编代码为[rbp+72] = [rbp+48h]
/// 所以运行时intArray的首地址为[rbp+48h]
intArray$ = 72


//////////////////////////// Main函数C++代码和对应的汇编代码 ////////////////////////////
main	PROC						; COMDAT

; 6    : &#123;
; 7    : 	printf(&quot;Hello Wolrd!\n&quot;);
   
    /// 取出字符地址，将地址赋值给rcx寄存器传参，调用print函数
    lea	rcx, OFFSET FLAT:??_C@_0O@DDOOOAMO@Hello?5Wolrd?$CB?6@
    call	printf

; 8    : 	string s = &quot;I am string&quot;;

    lea	rdx, OFFSET FLAT:??_C@_0M@CFPJMFMA@I?5am?5string@
    lea	rcx, QWORD PTR s$[rbp]
    ; std::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt; &gt;
    call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z

; 9    : 	int intArray[3] = &#123; 1,2,3 &#125;;
    /// 数组相对rbp偏移
    mov	DWORD PTR intArray$[rbp], 1
    mov	DWORD PTR intArray$[rbp+4], 2
    mov	DWORD PTR intArray$[rbp+8], 3

; 11   : 	const int iVar = 1;

    mov	DWORD PTR iVar$[rbp], 1

; 12   : 	printf(&quot;%d\n&quot;, iVar);
    /// 常量直接编译成立即数
    mov	edx, 1
    lea	rcx, OFFSET FLAT:??_C@_03PMGGPEJJ@?$CFd?6@
    call	printf

; 13   : #define IVAR 2
; 14   : 	printf(&quot;%d\n&quot;, iVar);

    mov	edx, 1
    lea	rcx, OFFSET FLAT:??_C@_03PMGGPEJJ@?$CFd?6@
    call	printf

	...
; 17   : &#125;
</code></pre></li></ul></li></ul><h2 id="4-变量基础"><a class="anchor" href="#4-变量基础">#</a>   4. 变量基础</h2><ul><li>变量：可以变化的量，是可读可写的内存！</li><li>变量有<strong>作用域和生命周期</strong><ul><li>作用域指在源码中可以被访问到的范围。</li><li>生命周期是变量所在的内存从分配到释放的时间。</li></ul></li></ul><h2 id="4-全局变量"><a class="anchor" href="#4-全局变量">#</a>   4. 全局变量</h2><ul><li>全局变量和常量类似，被写入可执行文件中，生命周期起源于执行文件被系统加载后，执行第一条代码前，这个时候已经具有内存地址了。<br>程序结束运行并退出后，全局变量将被销毁。因此全局变量可以在程序的任何位置使用！</li><li>代码示例：<pre><code class="language-C++">int g_iVar = 0;

int main( )
&#123;
    ... 
	        printf(&quot;%d&quot;, g_iVar );
    /// 全局变量g_iVar的地址07FF73D7EC170h属于全局数据区
    mov         edx,dword ptr [g_iVar (07FF73D7EC170h)]  
    lea         rcx,[string &quot;%d&quot; (07FF73D7E9C24h)]  
    call        printf (07FF73D7E1190h)  
          return 0;
    xor         eax,eax  
&#125;

////////////////////////////////// asm文件 //////////////////////////////////
/// 全局变量g_iVar定义如下
/// PUBLIC表示本模块和外部模块都可以访问变量g_iVar
/// 因为g_iVar初始化为0，所以在段BSS中。
PUBLIC	?g_iVar@@3HA					; g_iVar
_BSS	SEGMENT
?g_iVar@@3HA DD	01H DUP (?)				; g_iVar
_BSS	ENDS


/// main函数汇编程序
main	PROC						; COMDAT
; 8    : &#123;
...

; 9    : 	printf(&quot;%d&quot;, g_iVar );

	mov	edx, DWORD PTR ?g_iVar@@3HA		; g_iVar
	lea	rcx, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd@
	call	printf

; 10   : 	return 0;

	xor	eax, eax

; 11   : &#125;
</code></pre></li></ul><h2 id="5-局部变量"><a class="anchor" href="#5-局部变量">#</a>   5. 局部变量</h2><ul><li>局部变量作用域在 “{}” 中，生命周期起始于程序执行变量定义（内存分配），终止于 “}”（内存释放）。</li><li>局部变量作用于函数体内，在栈上分配内存。<pre><code class="language-C++">int main( )
&#123;
    ...
	        bool bVar = 1;
    /// rbp是栈基底指针，为局部变量bVar在栈上分配内存[rbp+4,rbp+8]，并赋初值1。
    mov         byte ptr [rbp+4],1  
	        printf(&quot;%d&quot;, bVar );
    /// 将bVar作为第二个参数传递给print
    movzx       eax,byte ptr [rbp+4]  
    mov         edx,eax  
    /// 取第一个参数%d常量的内存地址，并赋值传参
    lea         rcx,[string &quot;%d&quot; (00007FF6216A9C24h)]  
    /// 调用print函数，这里是print函数的首地址
    call        printf (00007FF6216A1190)
	        return 0;
    xor         eax,eax  
&#125;
    /// 释放局部变量！由栈平衡释放局部变量，栈寄存器rbp+rsp还原到调用者保存的栈寄存器数据。
    /// 程序跳出该函数，将执行权返回给调用者！
    /// 具体原理函数章节会细讲！
    lea	rsp, QWORD PTR [rbp+200]
    pop	rdi
    pop	rbp
    ret	0
</code></pre></li></ul><h2 id="6-静态变量"><a class="anchor" href="#6-静态变量">#</a>   6. 静态变量</h2><ul><li>全局静态变量<ul><li>全局静态变量和全局变量类似，只是全局静态变量只能在当前文件使用，但这只是 C++ 编译器语法检查对其作出的限制。</li><li>生命周期和全局变量一致。作用域在 C++ 中仅限当前文件使用，但在汇编语言中和全局变量一致。</li><li>所以全局静态变量等价于 C++ 编译器限制外部文件访问的全局变量。</li></ul></li><li>局部静态变量<ul><li>从下面的汇编代码中可知，局部静态变量和全局静态变量的定义和使用完全一致，那么怎么限制局部静态只作用域函数体内 “{}”？</li><li>估计和全局静态变量一样，是 C++ 编译器对局部静态变量的语法作出的限制</li></ul></li><li>代码示例：<pre><code class="language-C++">static int g_iVar = 1;
int main( )
&#123;
    ... 
	        printf( &quot;%d\n&quot;, g_iVar );
    mov         edx,dword ptr [g_iVar (07FF77B4EC000h)]  
    lea         rcx,[string &quot;%d&quot; (07FF77B4E9C24h)]  
    call        main (07FF77B4E1190h)  
    
    /// 问题1：这里竟然没有局部静态变量赋初值的汇编代码？？？答案请见asm文件。
    /// 问题2：众所周知，C++局部静态变量赋初值的代码只执行一次，那么汇编语言是怎么实现的？
	        static int iVar = 2;
	        printf( &quot;%d\n&quot;, iVar );
    /// 这三句全是printf传参和调用的代码
    mov         edx,dword ptr [iVar (07FF77B4EC004h)]  
    lea         rcx,[string &quot;%d&quot; (07FF77B4E9C24h)]  
    call        printf (07FF77B4E1190h) 
    
	        iVar++;
    /// 对比上面的g_iVar内存地址，可知局部静态变量iVar也在全局数据区
    mov         eax,dword ptr [iVar (07FF77B4EC004h)]  
    inc         eax  
    mov         dword ptr [iVar (07FF77B4EC004h)],eax 
    
	        printf( &quot;%d\n&quot;, iVar );
    mov         edx,dword ptr [iVar (07FF77B4EC004h)]  
    lea         rcx,[string &quot;%d&quot; (07FF77B4E9C24h)]  
    call        printf (07FF77B4E1190h)  
	        return 0;
    xor         eax,eax  
&#125;

////////////////////////////////// asm文件 //////////////////////////////////
/// 全局静态变量和局部静态变量都定义在DATA数据段中。
/// 问题1-答案：因为局部静态变量的初值被写入了文件，和全局变量一样在可执行文件被系统加载后，第一段代码执行前就已经被赋了初值，所以没有也不需要在函数中赋初值的汇编代码！
/// 问题2-答案：因为初值早就有了，函数体内也没有赋初值的汇编代码，所以也就实现了C++所谓的局部静态变量赋初值代码只会执行一次的功能！
_DATA	SEGMENT
?g_iVar@@3HA DD	01H					; g_iVar
?iVar@?1??main@@9@4HA DD 02H				; `main'::`2'::iVar
_DATA	ENDS


/// Main函数代码
_TEXT	SEGMENT
main	PROC						; COMDAT

; 7    : &#123;
        ...
; 8    : 	printf( &quot;%d\n&quot;, g_iVar );

	mov	edx, DWORD PTR ?g_iVar@@3HA
	lea	rcx, OFFSET FLAT:??_C@_03PMGGPEJJ@?$CFd?6@
	call	printf

; 10   : 	static int iVar = 2;
; 11   : 	printf( &quot;%d\n&quot;, iVar );

	mov	edx, DWORD PTR ?iVar@?1??main@@9@4HA
	lea	rcx, OFFSET FLAT:??_C@_03PMGGPEJJ@?$CFd?6@
	call	printf

; 12   : 	iVar++;

	mov	eax, DWORD PTR ?iVar@?1??main@@9@4HA
	inc	eax
	mov	DWORD PTR ?iVar@?1??main@@9@4HA, eax

; 13   : 	printf( &quot;%d\n&quot;, iVar );

	mov	edx, DWORD PTR ?iVar@?1??main@@9@4HA
	lea	rcx, OFFSET FLAT:??_C@_03PMGGPEJJ@?$CFd?6@
	call	printf

; 14   : 	return 0;

	xor	eax, eax

; 15   : &#125;
    ...
main	ENDP
_TEXT	ENDS
</code></pre></li></ul><h2 id="7-成员变量"><a class="anchor" href="#7-成员变量">#</a>   7. 成员变量</h2><ul><li>面对对象 =》对象 = 成员变量 + 函数 = 属性 + 方法</li><li>成员变量的生命周期为：对象的内存分配 到 对象的销毁<ul><li>new 的堆对象生命周期：new 到 delete</li><li>栈对象：对象栈内存分配 到 “}”</li></ul></li><li>成员变量的作用域：public、protect、private（面对对象三大特性之封装）</li><li>成员变量的读写：对象首地址 + 偏移地址（段地址 + 偏移地址）</li><li>代码示例<pre><code class="language-C++">class People
&#123;
public:
  int m_iAge;
  bool m_bIsWoman;
&#125;;

int main( )
&#123;
      ... 
          People* pPepole = new People();
   /// ...分配内存、初始化

          pPepole-&gt;m_iAge = 22;
   /// 将pPepole的首地址放入rax寄存器中
   mov         rax,qword ptr [pPepole] 
   /// 为m_iAge赋值。People中没有虚函数，所以对象的前四个字节就是成员变量m_iAge
   mov         dword ptr [rax],16h 

          pPepole-&gt;m_bIsWoman = false;
   /// 同理
   mov         rax,qword ptr [pPepole]
   /// 为m_bIsWoman赋值，rax+4偏移到成员变量m_bIsWoman的内存地址
   mov         byte ptr [rax+4],0 

          delete pPepole;
   /// ...销毁

          return 0;
   xor         eax,eax  
&#125;
</code></pre></li></ul><h2 id="8-总结"><a class="anchor" href="#8-总结">#</a>   8. 总结</h2><ul><li>全局变量、全局静态变量、局部静态变量、常量在程序代码运行前就已经分配了内存，所以可以通过内存地址直接寻址！</li><li>局部变量在运行时分配栈内存，是通过栈寄存器（rsp\rbp + 立即数）间接寻址（段 + 偏移）。</li><li>成员变量是通过通用寄存器间接寻址 [段 (对象首地址) + 偏移（立即数）]。</li><li>无论是变量还是常量都有内存地址和内存空间（内存地址 + 数据长度）！所以很多情况下知道内存地址 + 数据长度可以强制修改这块内存的值。</li></ul><h1 id="四-指针-引用-数组"><a class="anchor" href="#四-指针-引用-数组">#</a> 四、指针、引用、数组</h1><h2 id="1-指针和引用"><a class="anchor" href="#1-指针和引用">#</a>   1. 指针和引用</h2><ul><li>一级指针和引用在汇编语言中没有任何区别！那么 C++ 为什么还要实现一个引用的写法？<ul><li>原因 1：简化一级指针。其实引用就是一级指针 int&amp; 等价于 int*，不需要使用 * 访问，也不需要判空。</li><li>原因 2：方便理解。引用就是变量的别名，这是 C++ 程序员对引用最常见的理解，因为引用和原来的变量使用方法别无二致！</li></ul></li><li>引用和指针都占用相同大小的内存空间来存储目标地址，空间的大小由地址的长度决定。32 位程序占用 4 字节（地址长度为 4 字节），64 位程序占用 8 字节。</li><li>至于 C++ 中引用必须赋初值，那是 C++ 编译器作出的限制。</li><li>在以前学习 C++ 时，关于网上流传的引用传递比一级指针传递快啥啥的，我现在表示否定。经过测试引用传递和一级指针传递代码一模一样！</li><li>代码示例：<pre><code class="language-C++">int main( )
&#123;
   ... 
          int iVar = 10;
   mov         dword ptr [rbp+4],0Ah  

          int* pVar = &amp;iVar;
   /// 定义并赋值pVar
   lea         rax,[rbp+4]  
   mov         qword ptr [rbp+28h],rax  
          (*pVar)++;
   /// 取pVar所指向的内存地址放入rax中
   mov         rax,qword ptr [rbp+28h]  
   /// 取变量iVar的值放入eax中
   mov         eax,dword ptr [rax]  
   /// 加一
   inc         eax  
   /// 取pVar所指向的内存地址
   mov         rcx,qword ptr [rbp+28h]  
   /// 将计算结果eax中的数据放入pVar所指向的内存地址
   mov         dword ptr [rcx],eax  

          int&amp; rVar = iVar;
   /// 定义并赋值rVar，比较上面的pVar代码可知：引用和一级指针的汇编代码一模一样！
   lea         rax,[rbp+4]  
   mov         qword ptr [rbp+48h],rax  
          rVar++;
   mov         rax,qword ptr [rbp+48h]  
   mov         eax,dword ptr [rax]  
   inc         eax  
   mov         rcx,qword ptr [rbp+48h]  
   mov         dword ptr [rcx],eax  

          printf( &quot;%d\n&quot;, iVar );
   mov         edx,dword ptr [rbp+4]  
   lea         rcx,[string &quot;%d\n&quot; (07FF7C747ABC8h)]  
   call        printf (07FF7C7471447h)
  
   /// 引用和一级指针的汇编代码一模一样
          printf( &quot;%d\n&quot;, *pVar );
   mov         rax,qword ptr [rbp+28h]  
   mov         edx,dword ptr [rax]  
   lea         rcx,[string &quot;%d\n&quot; (07FF7C747ABC8h)]  
   call        printf (07FF7C7471447h)    
          printf( &quot;%d\n&quot;, rVar );
   mov         rax,qword ptr [rbp+48h]  
   mov         edx,dword ptr [rax]  
   lea         rcx,[string &quot;%d\n&quot; (07FF7C747ABC8h)]  
   call        printf (07FF7C7471447h)   
          return 0;
   xor         eax,eax  
&#125;
</code></pre></li></ul><h2 id="2-数组"><a class="anchor" href="#2-数组">#</a>   2. 数组</h2><ul><li>想同类型、连续空间</li><li>数组名和指针一样，占用空间，存储数组首地址。</li></ul><h1 id="五-表达式"><a class="anchor" href="#五-表达式">#</a> 五、表达式</h1><ul><li>表达式计算基本流程： 根据操作数的内存地址，取出操作数据放入寄存器 =&gt; 执行表达式指令 =&gt; 将表达式计算结果放入寄存器 =&gt; 将结果放入目标内存</li><li>常用的表达式指令：<ul><li>add：加法</li><li>sub：减法</li><li>mul（imul）：乘法</li><li>div（idiv）：除法</li><li>sal（shl）：左移</li><li>sar（shr）：右移</li><li>cmp 指令 (英文单词：compare) =》设置标志位（存储在标志寄存器中）：实现各种关系运算和逻辑运算，如：==、!=、&gt;=、&lt;=、&gt;、&lt;、||、&amp;&amp;、!</li><li>...</li><li>注意：如果汇编指令和 C++ 代码不对应，可能是被汇编编译器优化了！比如：3*2 = 3&lt;&lt;1，因为左移指令速度快于乘法指令，所以会被优化。</li></ul></li></ul><h1 id="六-流程控制语句"><a class="anchor" href="#六-流程控制语句">#</a> 六、流程控制语句</h1><ul><li><p>C++ 中的 if、switch、while、for、？等流程控制语句，在汇编语言中都是 cmp + jump 等指令实现</p><ul><li>C++ 被抛弃的 goto 语句和汇编语言的 jump 等指令，在原理和使用方法上惊人的相似！</li></ul></li><li><p>jump 等指令</p><ul><li>jmp 目标地址 =》代码跳转到目标地址<ul><li>C++ 的流程控制语句中 jump 的目标地址都是<strong>段内</strong>地址，甚至都是函数体内地址，所以一般都是 =》 jump short 目标地址</li><li>当然汇编语言的 jump 等指令也有能力将代码在<strong>段与段之间</strong>跳跃！</li></ul></li><li>jge 目标地址 =》大于等于跳转（jump if greater or equal）</li><li>jle 目标地址 =》小于等于跳转</li><li>jnz 目标地址 =》如果不等于 0 则跳转（jump if not zero）</li><li>je 目标地址 =》等于则跳转</li><li>...</li></ul></li><li><p>汇编代码示例：</p><pre><code class="language-C++">int main( )
&#123;
  ... 
      int iVar = 0;
  00007FF6D7105E6B  mov         dword ptr [iVar],0  
      for ( ; iVar &lt; 5; ++iVar )
  /// 初始化语句只执行一次，当然我这这个for没有初始化语句块
  /// 第一次执行跳过自增语句块++iVar
  00007FF6D7105E72  jmp         main+2Ch (07FF6D7105E7Ch) 
  /// ++iVar
  00007FF6D7105E74  mov         eax,dword ptr [iVar]  
  00007FF6D7105E77  inc         eax  
  00007FF6D7105E79  mov         dword ptr [iVar],eax 
  /// iVar&lt;5 cmp比较iVar和5的大小，然后设置标志寄存器中的相关标志位
  00007FF6D7105E7C  cmp         dword ptr [iVar],5  
  /// 判断前面cmp影响的标志寄存器结果，如果满足大于等于则跳转到目标地址，也就是for之外的第一句代码
  00007FF6D7105E80  jge         main+0F0h (07FF6D7105F40h)  
      &#123;
  	    printf(&quot;%d\n&quot;, iVar);
  00007FF6D7105E86  mov         edx,dword ptr [iVar]  
  00007FF6D7105E89  lea         rcx,[string &quot;%d\n&quot; (07FF6D710ABC8h)]  
  00007FF6D7105E90  call        _vfprintf_l (07FF6D7101447h)  
  	    if ( iVar &gt; 3 )
  /// 比较大小，设置标志寄存器中的标志位
  00007FF6D7105E95  cmp         dword ptr [iVar],3  
  /// 根据相关标志寄存器的结果，结果为小于等于则跳转
  00007FF6D7105E99  jle         main+5Ch (07FF6D7105EACh)  
  	    &#123;
  		    printf( &quot;%d\n&quot;, iVar );
  00007FF6D7105E9B  mov         edx,dword ptr [iVar]  
  00007FF6D7105E9E  lea         rcx,[string &quot;%d\n&quot; (07FF6D710ABC8h)]  
  00007FF6D7105EA5  call        _vfprintf_l (07FF6D7101447h)  
  	    &#125;
  /// 前面的if已经被执行，所以要跳过else的代码，跳转到下一段switch的代码
  00007FF6D7105EAA  jmp         main+6Bh (07FF6D7105EBBh)  
  	    else
  	    &#123;
  		    printf( &quot;%d\n&quot;, iVar );
  00007FF6D7105EAC  mov         edx,dword ptr [iVar]  
  00007FF6D7105EAF  lea         rcx,[string &quot;%d\n&quot; (07FF6D710ABC8h)]  
  00007FF6D7105EB6  call        _vfprintf_l (07FF6D7101447h)  
  	    &#125;

  	    switch (iVar)
  /// 判断iVar的值和关键数据匹配，匹配成功则跳转到目标Case语句块
  00007FF6D7105EBB  mov         eax,dword ptr [iVar]  
  00007FF6D7105EBE  mov         dword ptr [rbp+0D4h],eax  
  00007FF6D7105EC4  cmp         dword ptr [rbp+0D4h],0  
  00007FF6D7105ECB  je          main+9Ah (07FF6D7105EEAh)  
  00007FF6D7105ECD  cmp         dword ptr [rbp+0D4h],1  
  00007FF6D7105ED4  je          main+0ABh (07FF6D7105EFBh)  
  00007FF6D7105ED6  cmp         dword ptr [rbp+0D4h],2  
  00007FF6D7105EDD  je          main+0BCh (07FF6D7105F0Ch)  
  00007FF6D7105EDF  cmp         dword ptr [rbp+0D4h],3  
  00007FF6D7105EE6  je          main+0CDh (07FF6D7105F1Dh)  
  /// 都没匹配上则跳转到default语句块
  00007FF6D7105EE8  jmp         main+0DCh (07FF6D7105F2Ch)  
  	    &#123;
  	    case 0:
  		    printf( &quot;%d\n&quot;, iVar );
  00007FF6D7105EEA  mov         edx,dword ptr [iVar]  
  00007FF6D7105EED  lea         rcx,[string &quot;%d\n&quot; (07FF6D710ABC8h)]  
  00007FF6D7105EF4  call        _vfprintf_l (07FF6D7101447h)  
  		    break;
  /// 跳出Switch语句
  00007FF6D7105EF9  jmp         main+0EBh (07FF6D7105F3Bh)  
  	    case 1:
  		    printf( &quot;%d\n&quot;, iVar );
  00007FF6D7105EFB  mov         edx,dword ptr [iVar]  
  00007FF6D7105EFE  lea         rcx,[string &quot;%d\n&quot; (07FF6D710ABC8h)]  
  00007FF6D7105F05  call        _vfprintf_l (07FF6D7101447h)  
  		    break;
  00007FF6D7105F0A  jmp         main+0EBh (07FF6D7105F3Bh)  
  	    case 2:
  		    printf( &quot;%d\n&quot;, iVar );
  00007FF6D7105F0C  mov         edx,dword ptr [iVar]  
  00007FF6D7105F0F  lea         rcx,[string &quot;%d\n&quot; (07FF6D710ABC8h)]  
  00007FF6D7105F16  call        _vfprintf_l (07FF6D7101447h)  
  		    break;
  00007FF6D7105F1B  jmp         main+0EBh (07FF6D7105F3Bh)  
  	    case 3:
  		    printf( &quot;%d\n&quot;, iVar );
  00007FF6D7105F1D  mov         edx,dword ptr [iVar]  
  00007FF6D7105F20  lea         rcx,[string &quot;%d\n&quot; (07FF6D710ABC8h)]  
  00007FF6D7105F27  call        _vfprintf_l (07FF6D7101447h)  
  /// 这里我故意没有写break，当执行case 3时，因为没有C++代码没有break，所以这里不会跳出switch
  /// 继续执行后面的代码
  	    default:
  		    printf( &quot;%d\n&quot;, iVar );
  00007FF6D7105F2C  mov         edx,dword ptr [iVar]  
  00007FF6D7105F2F  lea         rcx,[string &quot;%d\n&quot; (07FF6D710ABC8h)]  
  00007FF6D7105F36  call        _vfprintf_l (07FF6D7101447h)  
  		    break;
  	    &#125;
      &#125;
  /// for循环末尾，跳转回去，继续for循环
  /// 注意跳转的目标地址，其中for的初始化语句不会再执行，直接执行++iVar语句和条件判断语句
  00007FF6D7105F3B  jmp         main+24h (07FF6D7105E74h)  
      
  /// 同理
      while ( --iVar )
  00007FF6D7105F40  mov         eax,dword ptr [iVar]  
  00007FF6D7105F43  dec         eax  
  00007FF6D7105F45  mov         dword ptr [iVar],eax  
  00007FF6D7105F48  cmp         dword ptr [iVar],0  
  00007FF6D7105F4C  je          main+10Fh (07FF6D7105F5Fh)  
      &#123;
  	    printf( &quot;%d\n&quot;, iVar );
  00007FF6D7105F4E  mov         edx,dword ptr [iVar]  
  00007FF6D7105F51  lea         rcx,[string &quot;%d\n&quot; (07FF6D710ABC8h)]  
  00007FF6D7105F58  call        _vfprintf_l (07FF6D7101447h)  
      &#125;
  00007FF6D7105F5D  jmp         main+0F0h (07FF6D7105F40h)  

      return 0;
  00007FF6D7105F5F  xor         eax,eax  
&#125;
</code></pre></li></ul><div class="tags"><a href="/tags/Assembly-Language/" rel="tag"><i class="ic i-tag"></i> Assembly Language</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">編集日</span> <time title="修正日：2022-11-19 17:31:50" itemprop="dateModified" datetime="2022-11-19T17:31:50+08:00">2022-11-19</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 寄付</button><p>*~(￣▽￣)~[お茶]を一杯ください</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="XiaoLiang WeChat 支払う"><p>WeChat 支払う</p></div><div><img data-src="/images/alipay.png" alt="XiaoLiang Alipay"><p>Alipay</p></div></div></div><div id="copyright"><ul><li class="author"><strong>著者： </strong>XiaoLiang <i class="ic i-at"><em>@</em></i>打爆你滴脑阔</li><li class="link"><strong>記事へのリンク：</strong> <a href="https://xiaoliangcoder.github.io/Source/Assembly/AssemblyLanguagePrimary/" title="C++反汇编语言 - 入门">https://xiaoliangcoder.github.io/Source/Assembly/AssemblyLanguagePrimary/</a></li><li class="license"><strong>著作権表示： </strong>このブログ内のすべての記事は、特別な記載がない限り <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> の下のライセンスで保護されています。</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/Source/Assembly/AssemblyLanguageBase/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;api.ixiaowai.cn&#x2F;mcapi&#x2F;mcapi2.php" title="汇编语言 - 基础总结"><span class="type">前の記事</span> <span class="category"><i class="ic i-flag"></i> AssemblyLanguageBase</span><h3>汇编语言 - 基础总结</h3></a></div><div class="item right"><a href="/Source/UnrealEngine/EditorExtend/EditorExtendIntermediate/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;api.dujin.org&#x2F;pic&#x2F;yuanshen&#x2F;" title="UE5 编辑器扩展（进阶篇）"><span class="type">次の記事</span> <span class="category"><i class="ic i-flag"></i> EditorExtend</span><h3>UE5 编辑器扩展（进阶篇）</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="見出し"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">一、简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">二、基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE"><span class="toc-number">2.1.</span> <span class="toc-text">1. 定义数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80-%E6%AE%B5%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-number">2.2.</span> <span class="toc-text">2. 汇编语言 - 段（伪指令）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-vs%E5%8F%8D%E6%B1%87%E7%BC%96"><span class="toc-number">2.3.</span> <span class="toc-text">3. VS 反汇编</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">三、常量和变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F%E7%AE%80%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">1. 常量和变量简述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AE%8F"><span class="toc-number">3.2.</span> <span class="toc-text">2. 宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-const%E5%B8%B8%E9%87%8F"><span class="toc-number">3.3.</span> <span class="toc-text">3. const 常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B8%B8%E9%87%8F%E6%80%BB%E7%BB%93"><span class="toc-number">3.4.</span> <span class="toc-text">3. 常量总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8F%98%E9%87%8F%E5%9F%BA%E7%A1%80"><span class="toc-number">3.5.</span> <span class="toc-text">4. 变量基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">3.6.</span> <span class="toc-text">4. 全局变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">3.7.</span> <span class="toc-text">5. 局部变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">3.8.</span> <span class="toc-text">6. 静态变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">3.9.</span> <span class="toc-text">7. 成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%80%BB%E7%BB%93"><span class="toc-number">3.10.</span> <span class="toc-text">8. 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B-%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8-%E6%95%B0%E7%BB%84"><span class="toc-number">4.</span> <span class="toc-text">四、指针、引用、数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">1. 指针和引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84"><span class="toc-number">4.2.</span> <span class="toc-text">2. 数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">五、表达式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.</span> <span class="toc-text">六、流程控制语句</span></a></li></ol></div><div class="related panel pjax" data-title="関連記事"><ul><li class="active"><a href="/Source/Assembly/AssemblyLanguagePrimary/" rel="bookmark" title="C++反汇编语言 - 入门">C++反汇编语言 - 入门</a></li><li><a href="/Source/Assembly/AssemblyLanguageIntermediate/" rel="bookmark" title="C++反汇编语言 - 进阶">C++反汇编语言 - 进阶</a></li></ul></div><div class="overview panel" data-title="概要"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="XiaoLiang" data-src="/images/avatar.jpg"><p class="name" itemprop="name">XiaoLiang</p><div class="description" itemprop="description">黑不溜qiu的抠脚大汉</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">11</span> <span class="name">ポスト</span></a></div><div class="item categories"><a href="/categories/"><span class="count">13</span> <span class="name">カテゴリ</span></a></div><div class="item tags"><a href="/tags/"><span class="count">9</span> <span class="name">タグ</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>ホーム</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/Source/Assembly/AssemblyLanguageBase/" rel="prev" title="前の記事"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/Source/UnrealEngine/EditorExtend/EditorExtendIntermediate/" rel="next" title="次の記事"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>ランダムな記事</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/UnrealEngine/" title="カテゴリ UnrealEngine">UnrealEngine</a> <i class="ic i-angle-right"></i> <a href="/categories/UnrealEngine/Editor/" title="カテゴリ Editor">Editor</a> <i class="ic i-angle-right"></i> <a href="/categories/UnrealEngine/Editor/EditorExtend/" title="カテゴリ EditorExtend">EditorExtend</a></div><span><a href="/Source/UnrealEngine/EditorExtend/EditorExtendMenuSource/" title="UE5 编辑器扩展（源码篇）">UE5 编辑器扩展（源码篇）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UnrealEngine/" title="カテゴリ UnrealEngine">UnrealEngine</a> <i class="ic i-angle-right"></i> <a href="/categories/UnrealEngine/AutomationTest/" title="カテゴリ AutomationTest">AutomationTest</a></div><span><a href="/Source/UnrealEngine/AutomationTest/AutomationTest/" title="UE5 自动化测测试">UE5 自动化测测试</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Assembly/" title="カテゴリ Assembly">Assembly</a> <i class="ic i-angle-right"></i> <a href="/categories/Assembly/AssemblyLanguageBase/" title="カテゴリ AssemblyLanguageBase">AssemblyLanguageBase</a></div><span><a href="/Source/Assembly/AssemblyLanguageBase/" title="汇编语言 - 基础总结">汇编语言 - 基础总结</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Network/" title="カテゴリ Network">Network</a> <i class="ic i-angle-right"></i> <a href="/categories/Network/NetworkBase/" title="カテゴリ NetworkBase">NetworkBase</a></div><span><a href="/Source/Network/NetworkBase/" title="网络游戏基础">网络游戏基础</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UnrealEngine/" title="カテゴリ UnrealEngine">UnrealEngine</a> <i class="ic i-angle-right"></i> <a href="/categories/UnrealEngine/Editor/" title="カテゴリ Editor">Editor</a> <i class="ic i-angle-right"></i> <a href="/categories/UnrealEngine/Editor/EditorExtend/" title="カテゴリ EditorExtend">EditorExtend</a></div><span><a href="/Source/UnrealEngine/EditorExtend/EditorExtendIntermediate/" title="UE5 编辑器扩展（进阶篇）">UE5 编辑器扩展（进阶篇）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UnrealEngine/" title="カテゴリ UnrealEngine">UnrealEngine</a> <i class="ic i-angle-right"></i> <a href="/categories/UnrealEngine/Input/" title="カテゴリ Input">Input</a></div><span><a href="/Source/UnrealEngine/Input/InputFramework/" title="UE5 输入系统">UE5 输入系统</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Assembly/" title="カテゴリ Assembly">Assembly</a> <i class="ic i-angle-right"></i> <a href="/categories/Assembly/AssemblyLanguagePrimary/" title="カテゴリ AssemblyLanguagePrimary">AssemblyLanguagePrimary</a></div><span><a href="/Source/Assembly/AssemblyLanguageIntermediate/" title="C++反汇编语言 - 进阶">C++反汇编语言 - 进阶</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UnrealEngine/" title="カテゴリ UnrealEngine">UnrealEngine</a> <i class="ic i-angle-right"></i> <a href="/categories/UnrealEngine/Editor/" title="カテゴリ Editor">Editor</a> <i class="ic i-angle-right"></i> <a href="/categories/UnrealEngine/Editor/EditorExtend/" title="カテゴリ EditorExtend">EditorExtend</a></div><span><a href="/Source/UnrealEngine/EditorExtend/EditorExtendSample/" title="UE5 编辑器扩展（实战篇）">UE5 编辑器扩展（实战篇）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Assembly/" title="カテゴリ Assembly">Assembly</a> <i class="ic i-angle-right"></i> <a href="/categories/Assembly/AssemblyLanguagePrimary/" title="カテゴリ AssemblyLanguagePrimary">AssemblyLanguagePrimary</a></div><span><a href="/Source/Assembly/AssemblyLanguagePrimary/" title="C++反汇编语言 - 入门">C++反汇编语言 - 入门</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Web/" title="カテゴリ Web">Web</a> <i class="ic i-angle-right"></i> <a href="/categories/Web/Website/" title="カテゴリ Website">Website</a> <i class="ic i-angle-right"></i> <a href="/categories/Web/Website/BuildGithubBlog/" title="カテゴリ BuildGithubBlog">BuildGithubBlog</a></div><span><a href="/Source/Web/Website/BuildGithubBlog/" title="使用Github搭建网站">使用Github搭建网站</a></span></li></ul></div><div><h2>最近のコメント</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">XiaoLiang @ Senior Brother</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"Source/Assembly/AssemblyLanguagePrimary/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"検索…",empty:"「 ${query} 」については何も見つかりませんでした",stats:"${time} ms以内に ${hits} 件の結果が見つかりました"},valine:!0,fancybox:!0,copyright:"コピーは成功しました。 <br> 再印刷については、 ％s 契約に従ってください。",ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->
<!-- build time:Sun May 14 2023 21:48:44 GMT+0800 (香港标准时间) --><!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="打爆你滴脑阔" href="https://xiaoliangcoder.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="打爆你滴脑阔" href="https://xiaoliangcoder.github.io/atom.xml"><link rel="alternate" type="application/json" title="打爆你滴脑阔" href="https://xiaoliangcoder.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="Navigation Recast"><link rel="canonical" href="https://xiaoliangcoder.github.io/Source/Navigation/Recast/"><title>Recast - Recast - Navigation | Senior Brother = 打爆你滴脑阔 = 笔记</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Recast</h1><div class="meta"><span class="item" title="作成日：2023-04-21 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">投稿日</span> <time itemprop="dateCreated datePublished" datetime="2023-04-21T00:00:00+08:00">2023-04-21</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="ナビゲーションバーの切り替え"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Senior Brother</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://api.ixiaowai.cn/api/api2.php"></li><li class="item" data-background-image="https://api.likepoems.com/img/aliyun/pc"></li><li class="item" data-background-image="https://api.r10086.com/img-api.php?type=动漫综合3"></li><li class="item" data-background-image="https://tuapi.eees.cc/api.php?category=dongman&type=302"></li><li class="item" data-background-image="https://api.yimian.xyz/img"></li><li class="item" data-background-image="https://api.dujin.org/pic/yuanshen/"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">ホーム</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Navigation/" itemprop="item" rel="index" title="カテゴリ Navigation"><span itemprop="name">Navigation</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Navigation/Recast/" itemprop="item" rel="index" title="カテゴリ Recast"><span itemprop="name">Recast</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-Hans"><link itemprop="mainEntityOfPage" href="https://xiaoliangcoder.github.io/Source/Navigation/Recast/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="XiaoLiang"><meta itemprop="description" content="笔记, 黑不溜qiu的抠脚大汉"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="打爆你滴脑阔"></span><div class="body md" itemprop="articleBody"><h1 id="一-简介"><a class="anchor" href="#一-简介">#</a> 一、简介</h1><ul><li>开源地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JlY2FzdG5hdmlnYXRpb24vcmVjYXN0bmF2aWdhdGlvbg==">RecastNavigation</span></li><li>RecastNav 寻路 = 导航网格 + 寻路算法。<ul><li>Recast 负责根据输入的环境网格 (Mesh)<strong> 生成导航网格</strong>。-&gt; 路径数据</li><li>Detour 使用导航网格<strong>寻路</strong>。-&gt; 路径算法</li><li>RecastDemo 使用 Recast+Detour 的一个示例工程。</li></ul></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81ODM4ODcwMjQ=">知乎大佬详解 Recast Navigation</span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81OTIzMzkxMzM=">知乎大佬详解 Recast Navigation</span></li></ul><h1 id="二-recastdemo-uml"><a class="anchor" href="#二-recastdemo-uml">#</a> 二、RecastDemo UML</h1><p><img data-src="RecastDemo.png" alt="Recast Demo"></p><ol><li>程序入口 Main 函数 - 初始化。</li><li>While 循环实现 Tick 功能。</li><li>构建 UI（文本、按钮...）。监听和处理输入。</li><li>输入环境网格，设置参数，生成导航网格（NavMesh）。</li><li>绘制显示。</li><li>调试和 Debug。</li></ol><h1 id="三-约定俗成"><a class="anchor" href="#三-约定俗成">#</a> 三、约定俗成</h1><ul><li>环境网格 (EnvMesh)：输入的源网格体数据，用于生成导航网格体数据。</li><li>导航网格 (NavMesh)：Recast 根据<strong>环境网格</strong>输出导航网格体数据，该网格数据用于寻路。</li></ul><h1 id="四-输入源环境网格"><a class="anchor" href="#四-输入源环境网格">#</a> 四、输入源 (环境网格)</h1><ul><li>RecastDemo 输入的环境网格是从 Obj 文件读取的。文件格式非常简单且两种数据，如下所示：<ul><li>顶点数据：v 32.471557617 31.175949097 3.788104773</li><li>三角形索引数据：f 1 2 3</li></ul></li><li>解析 Obj 文件，将顶点和索引数据存入下列数据结构中：<ul><li>float* rcMeshLoaderObj::m_verts; // 每三个组成一个顶点</li><li>int* rcMeshLoaderObj::m_tris; // 每三个组成一个三角形索引</li></ul></li><li>UE5 的环境网格是由引擎提供。</li></ul><h1 id="五-recast参数"><a class="anchor" href="#五-recast参数">#</a> 五、Recast 参数</h1><ul><li>单位 (Units)：Units are usually in voxels (vx) or world units (wu). The units for voxels, grid size, and cell size are all based on the values of #cs and #ch.<ul><li>vx：体素单位。这些单位全是 int 值，表示有多少个体素。体素的大小 width (XZ - 竖直面)/ 体素 height (Y - 高度)。</li><li>wu：世界单位。</li></ul></li><li>限制 (Limit)：数据值的限制范围。</li><li>坐标系：SDL 库 (Opengl) 是右手坐标系。<br><img data-src="CoordinateSystem.jpg" alt="Coordinate System"></li><li>C++ 参数</li></ul><pre><code class="language-C++">// Specifies a configuration to use when performing Recast builds.
struct rcConfig
&#123;
	/// The minimum/maximum bounds of the field's AABB. [(x, y, z)] [Units: wu]
	/// 环境Mesh中顶点XYZ的最大最小值构成的AABB包围盒，将环境都包含在内。
	/// 这个值也可以自定义，毕竟真实的游戏很复杂，有些区域不需要寻路，比如：水里、天空、不可到达的区域...
	float bmin[3]; 
	float bmax[3];

	/// The xz-plane/y-axis cell size/height to use for fields. [Limit: &gt; 0] [Units: wu] 
	/// 体素细分单位。体素长宽高单位大小。
	float cs; // cell size -&gt; 立方体XZ的大小 -&gt; XZ平面正方形
	float ch; // cell height -&gt; 立方体高度大小

	/// The width/height of the field along the x-axis/z-axis. [Limit: &gt;= 0] [Units: vx]
	/// 将上面的AABB包围盒细分。将X轴细分为width块，将Z轴细分为height块。
	int width;  // X轴细分。浮点数向上取整。如：width = (fAABBMax_X - fAABBMin_X)/(cs + 0.5f)
	int height; // Z轴细分。
		    // 注意：Y轴没有被细分。
	
	/// The size of the non-navigable border around the heightfield. [Limit: &gt;=0] [Units: vx]
	/// 边界区域大小，这些边界区域不会生成导航网格。
	int borderSize;

	/// The width/height size of tile's on the xz-plane. [Limit: &gt;= 0] [Units: vx]
	int tileSize;
	
	/// The maximum slope that is considered walkable. [Limits: 0 &lt;= value &lt; 90] [Units: Degrees]
	/// 爬坡下坎的角度，斜面超过这个角度不能导航。 
	float walkableSlopeAngle;

	/// Minimum floor to 'ceiling(天花板)' height 
	/// that will still allow the floor area to be considered walkable. [Limit: &gt;= 3] [Units: vx] 
	/// 可行走的最小高度 - 体素坐标系 - 单位为体素的高
	int walkableHeight;
	
	/// Maximum ledge height that is considered to still be traversable. [Limit: &gt;=0] [Units: vx] 
	/// 可以攀爬的最大高度 - 体素坐标系 - 单位为体素的高
	int walkableClimb;
	
	/// The distance to erode/shrink the walkable area of the heightfield away from obstructions.  [Limit: &gt;=0] [Units: vx] 
	/// 行走半径。区域圆的半径大于该值时才可以行走。每个物体都有半径，行走物应该都有半径！[Limit: &gt;=0]
	int walkableRadius;
	
	/// The maximum allowed length for contour edges along the border of the mesh. [Limit: &gt;=0] [Units: vx]
	int maxEdgeLen;
	
	/// The maximum distance a simplified contour's border edges should deviate the original raw contour. [Limit: &gt;=0] [Units: vx]
	float maxSimplificationError;
	
	/// The minimum number of cells allowed to form isolated island areas. [Limit: &gt;=0] [Units: vx] 
	/// 平面XZ最小可行走区域。
	int minRegionArea;
	
	/// Any regions with a span count smaller than this value will, if possible, be merged with larger regions. [Limit: &gt;=0] [Units: vx] 
	int mergeRegionArea;
	
	/// The maximum number of vertices allowed for polygons generated during the contour to polygon conversion process. [Limit: &gt;= 3] 
	int maxVertsPerPoly;
	
	/// Sets the sampling distance to use when generating the detail mesh.(For height detail only.) [Limits: 0 or &gt;= 0.9] [Units: wu] 
	float detailSampleDist;
	
	/// The maximum distance the detail mesh surface should deviate from heightfield data. (For height detail only.) [Limit: &gt;=0] [Units: wu] 
	float detailSampleMaxError;
&#125;;
</code></pre><h1 id="六-体素化"><a class="anchor" href="#六-体素化">#</a> 六、体素化</h1><h2 id="1-概念"><a class="anchor" href="#1-概念">#</a> 1. 概念</h2><ul><li>光栅化：将三角形转换为<strong>二维平面的像素格子</strong>。</li><li>体素化：将三角形转换为<strong>三维的立方体格子</strong>。</li></ul><h2 id="2-效果图片"><a class="anchor" href="#2-效果图片">#</a> 2. 效果图片</h2><p><img data-src="Voxelization.jpg" alt="Voxelization"></p><ul><li>图 a 是三维模型，3D 美术师在 Maya 等软件中创建的三维网格体。</li><li>图 b-d 就是对图 a 的体素化，用一个一个立方体切割出来的体素模型。</li><li>RecastDemo 体素化图<br><img data-src="RecastDemo-Mode.png" alt="Recast Demo Mode"><br><img data-src="RecastDemo-Voxelization.png" alt="Recast Demo Voxelization"></li></ul><h2 id="3-专有名词解释"><a class="anchor" href="#3-专有名词解释">#</a> 3. 专有名词解释</h2><pre><code>![Recast Voxel 1](Recast-Voxel_1.png)
</code></pre><ul><li>立方体由长宽高三个属性确定，体素也一样：CellSize (X) * CellHeight (Y) * CellSize (Z)</li><li>Cell：一个体素 (Voxel)。</li><li>偷天换日：XYZ 轴的精度被偷换了！常用的 XYZ 轴的精度为 1，现在体素化中 XYZ 以体素大小为精度 (Width\Height\Depth)<ul><li>World X = Width * cs; //cs-&gt;CellSize，表示<strong> X 轴切割了 Width 份 cs 大小的单元</strong> 下面同理。-&gt; 详情可见 Recast 参数和代码</li><li>World Y = Height * ch; //ch-&gt;CellHeight</li><li>World Z = Depth(Height_Z) * cs;<br>// <strong>注：不论是代码还是参考资料里面，Height 关键字都容易混肴</strong><br>// 因为 Height 在代码中被使用在 Z 方向上，而计算机图形、游戏引擎、相关资料以及部分代码的字里行间它又被使用在 Y 方向上！<br>// 但计算机图形学和游戏引擎一直是 Y 表示高度，Z 表示深度！<br>// 所以本篇文章<strong> Z 轴的 Height_Z 使用 Depth，Y 轴使用 Height</strong> 来区分，相关代码也会特别标注是哪个轴向！</li></ul></li><li>BoundsMax/BoundMin：AABB 包围盒，表示整个体素化的范围，该范围内的所有输入的环境网格体都会被体素化，生成导航网格。<br><img data-src="Recast-Voxel_4.png" alt="Recast Voxel 4"></li><li><strong>Span</strong>：由<strong>一个或多个</strong>体素在<strong>竖直方向</strong>上的<strong>连续</strong>集合体。</li><li>SpanMax/SpanMin：Span 在 Y 轴上面的体素个数 CellNum = SpanMax - SpanMin</li><li>高度场 (rcHeightfield)：由 Width*Depth 个 Span** 二维指针组成，<strong>竖直</strong>串联所有的 Span * 对象。-&gt; 链表<br><img data-src="HeightField.png" alt="Height Field"><ul><li>可以想象，XZ 平面每个格子都有一个头指针（一一对应），然后像路边烧烤串串一样，将 Span 都对象串联起来，只不过是竖直放置的。</li><li>体素化过程中只有一个高度场对象，用来保存 “串串” 的<strong>二维</strong>头指针。</li><li>为什么要用二维头指针？-&gt; 这一串竖直方向上没有 Span 或者创建一个空 Span 作为头指针太浪费了！</li></ul></li></ul><h2 id="4-切割原理"><a class="anchor" href="#4-切割原理">#</a> 4. 切割原理</h2><ul><li><p>二维三角形切割 - 三维的投影<br><img data-src="VoxelTriangle_AxisXZ.jpg" alt="Voxel Triangle Axis X Z"></p><ul><li>首先 XZ 平面有一个三角形 OAB，然后先按 Z 轴横着切，再按 X 轴竖着切。 -&gt; 切块的大小 = CellSize</li><li>Z 轴第一刀将三角形切为两个多边形，一个是四边形 OCDB，一个是三角形 CAD。</li><li>X 轴第一刀将四边形 OCDB 切为两个四边形，一个是 OCGE，一个是 EGDB；然后再将 CAD 切成了两个多边形，一个是三角形 CFG，一个是四边形 FADG。</li><li>所以 OCGE 就在产生了一个 Span，此时该 Span 的 X 轴的 Width 和 Z 轴的 Depth 都已经确定 (被切出来的)。</li></ul></li><li><p>三维三角形切割 - 二维转到三维</p><ul><li>那么 Y 轴的 SpanMax/SpanMin 呢？只有确定了 SpanMax/SpanMin，才能表示一个完整的 Span 立方体，才能知道竖直方向上有多少个体素！</li><li>其实代码里面并没有真正的切割 Y 轴 (没有调用切割函数 dividePoly)，我刚开始也很困惑 (因为我脑阔还在二维空间中)，直到我把那段代码理解之后，恍然大悟！</li><li>Y 轴的 Height 其实在上面 XZ 轴切割的时候就已经可以算出来了！请看下图：<br><img data-src="Recast-Voxel_5.png" alt="Recast Voxel 5"></li><li>上图就是按照 XZ 轴切割后，一块 Span 和三角形的切割示例图。</li><li><strong>XZ 轴切割后是知道各个 Span 中多边形的顶点数据</strong>，比如上面示例红色立方体 Span 中的不规则五边形的五个顶点数据全部已知！</li><li>那么<strong> SpanMax = 多边形所有顶点 Y 的最大值向上取整，SpanMin = 多边形所有顶点 Y 的最小值向下取整</strong>（取整单位为 CellHeight）。</li></ul></li><li><p>切割代码</p></li></ul><pre><code class="language-C++">/// 体素化所有三角形
/// Rasterizes an indexed triangle mesh into the specified heightfield.
///
/// Spans will only be added for triangles that overlap the heightfield grid.
/// 
/// @see rcHeightfield
/// @ingroup recast
/// @param[in,out]	context				The build context to use during the operation.
/// @param[in]		verts				The vertices. [(x, y, z) * @p nv]
/// @param[in]		numVerts			The number of vertices. (unused) TODO (graham): Remove in next major release
/// @param[in]		tris				The triangle indices. [(vertA, vertB, vertC) * @p nt]
/// @param[in]		triAreaIDs			The area id's of the triangles. [Limit: &lt;= #RC_WALKABLE_AREA] [Size: @p nt]
/// @param[in]		numTris				The number of triangles.
/// @param[in,out]	heightfield			An initialized heightfield.
/// @param[in]		flagMergeThreshold	The distance where the walkable flag is favored over the non-walkable flag. 
///										[Limit: &gt;= 0] [Units: vx]
/// @returns True if the operation completed successfully.
bool rcRasterizeTriangles(rcContext* context, const float* verts, int numVerts, const int* tris,
				const unsigned char* triAreaIDs, int numTris,
				rcHeightfield&amp; heightfield, int flagMergeThreshold = 1)
&#123;
	...	
	// 体素大小的倒数
	const float inverseCellSize = 1.0f / heightfield.cs;
	const float inverseCellHeight = 1.0f / heightfield.ch;
	
	// 遍历三角形，依次体素化
	for (int triIndex = 0; triIndex &lt; numTris; ++triIndex)
	&#123;
		const float* v0 = &amp;verts[tris[triIndex * 3 + 0] * 3];
		const float* v1 = &amp;verts[tris[triIndex * 3 + 1] * 3];
		const float* v2 = &amp;verts[tris[triIndex * 3 + 2] * 3];
		// 体素化该三角形
		if (!rasterizeTri(v0, v1, v2, triAreaIDs[triIndex], heightfield, heightfield.bmin, heightfield.bmax, heightfield.cs, inverseCellSize, inverseCellHeight, flagMergeThreshold))
		&#123;
			context-&gt;log(RC_LOG_ERROR, &quot;rcRasterizeTriangles: Out of memory.&quot;);
			return false;
		&#125;
	&#125;

	return true;
&#125;




/// 体素化单个三角形
///	Rasterize a single triangle to the heightfield.
///
///	This code is extremely hot, so much care should be given to maintaining maximum perf here.
/// 
/// @param[in] 	v0					Triangle vertex 0
/// @param[in] 	v1					Triangle vertex 1
/// @param[in] 	v2					Triangle vertex 2
/// @param[in] 	areaID				The area ID to assign to the rasterized spans
/// @param[in] 	hf					Heightfield to rasterize into
/// @param[in] 	hfBBMin				The min extents of the heightfield bounding box
/// @param[in] 	hfBBMax				The max extents of the heightfield bounding box
/// @param[in] 	cellSize			The x and z axis size of a voxel in the heightfield
/// @param[in] 	inverseCellSize		1 / cellSize
/// @param[in] 	inverseCellHeight	1 / cellHeight
/// @param[in] 	flagMergeThreshold	The threshold in which area flags will be merged 
/// @returns true if the operation completes successfully.  false if there was an error adding spans to the heightfield.
static bool rasterizeTri(const float* v0, const float* v1, const float* v2,
                         const unsigned char areaID, rcHeightfield&amp; hf,
                         const float* hfBBMin, const float* hfBBMax,
                         const float cellSize, const float inverseCellSize, const float inverseCellHeight,
                         const int flagMergeThreshold)
&#123;
	//////////////////////// 代码较长，精简主要步骤 ////////////////////////
	
	/// 计算三角形的AABB包围盒 -&gt; 世界坐标
	// Calculate the bounding box of the triangle.
	float triBBMin[3];
	rcVcopy(triBBMin, v0);
	rcVmin(triBBMin, v1);
	rcVmin(triBBMin, v2);

	float triBBMax[3];
	rcVcopy(triBBMax, v0);
	rcVmax(triBBMax, v1);
	rcVmax(triBBMax, v2);
	
	/// 计算该三角形z方向上坐标 -&gt; 世界坐标转体素坐标 -&gt; z0和z1表示三角形在体素坐标内AABB包围盒在Z轴方向上的最大最小值！
	// Calculate the footprint of the triangle on the grid's z-axis
	int z0 = (int)((triBBMin[2] - hfBBMin[2]) * inverseCellSize);
	int z1 = (int)((triBBMax[2] - hfBBMin[2]) * inverseCellSize);
	/// 在Z轴上一刀一刀的横切
	for (int z = z0; z &lt;= z1; ++z)
	&#123;
		// 切割函数
		dividePoly(..., RC_AXIS_Z); // 枚举值RC_AXIS_Z表示按照Z轴切割
		
		/// 同z0和z1
		int x0 = (int)((minX - hfBBMin[0]) * inverseCellSize);
		int x1 = (int)((maxX - hfBBMin[0]) * inverseCellSize);
		/// 在X轴上一刀一刀的竖切
		for (int x = x0; x &lt;= x1; ++x)
		&#123;
			dividePoly(..., RC_AXIS_X);// 枚举值RC_AXIS_X表示按照X轴切割
			
			/// 遍历切割后的多边形顶点，求出顶点Y的最大最小值（spanMin/spanMax）
			// Calculate min and max of the span.
			float spanMin = p1[1];
			float spanMax = p1[1];
			for (int vert = 1; vert &lt; nv; ++vert)
			&#123;
				spanMin = rcMin(spanMin, p1[vert * 3 + 1]);
				spanMax = rcMax(spanMax, p1[vert * 3 + 1]);
			&#125;
			/// 减去体素坐标的世界坐标原点，转为体素坐标 -&gt; 但是精度还是世界坐标精度1
			spanMin -= hfBBMin[1];
			spanMax -= hfBBMin[1];
			
			/// 将spanMin/spanMax转为体素坐标精度
			// Snap the span to the heightfield height grid.
			unsigned short spanMinCellIndex = (unsigned short)rcClamp((int)floorf(spanMin * inverseCellHeight), 0, RC_SPAN_MAX_HEIGHT);
			unsigned short spanMaxCellIndex = (unsigned short)rcClamp((int)ceilf(spanMax * inverseCellHeight), (int)spanMinCellIndex + 1, RC_SPAN_MAX_HEIGHT);
			
			/// 添加Span
			if (!addSpan(hf, x, z, spanMinCellIndex, spanMaxCellIndex, areaID, flagMergeThreshold))
			&#123;
				return false;
			&#125;
		&#125;
	&#125;
&#125;




/// 按轴切割多边形
/// Divides a convex polygon of max 12 vertices into two convex polygons
/// across a separating axis.
/// 
/// @param[in]	inVerts			The input polygon vertices
/// @param[in]	inVertsCount	The number of input polygon vertices
/// @param[out]	outVerts1		Resulting polygon 1's vertices
/// @param[out]	outVerts1Count	The number of resulting polygon 1 vertices
/// @param[out]	outVerts2		Resulting polygon 2's vertices
/// @param[out]	outVerts2Count	The number of resulting polygon 2 vertices
/// @param[in]	axisOffset		THe offset along the specified axis
/// @param[in]	axis			The separating axis
static void dividePoly(const float* inVerts, int inVertsCount,
                       float* outVerts1, int* outVerts1Count,
                       float* outVerts2, int* outVerts2Count,
                       float axisOffset, rcAxis axis)
&#123;
	/// 切割算法 -&gt; 没有细看这部分源码 -&gt; 而且这部分源码因为优化非常&quot;好理解&quot;
	/// 每条边都可以确定一个直线线段（两点确定一条直线）-&gt; 可以求出直线方程
	/// 先判断相交情况，用线段的当前轴(axis)最大最小值和当前切割线(axisOffset)比大小，只有线段当前轴最小值&lt;axisOffset&lt;线段当前轴最大值才相交
	/// 相交后，将axisOffset带入直线方程求解就能得到交点

	/// 当前三角形和当前切割线的所有交点（最多只有两个[0-2]）
	/// 判断左右来区分切割后的两个多边形，同一边的就是同一个多边形！ -&gt; 判断左右和判断相交一样，比较大小就可以了
	/// 返回切割后的两个多边形顶点outVerts1/outVerts2和数量outVerts1Count/outVerts2Count
&#125;




/// 向高度场对象插入一个Span -&gt; 链表操作
/// Adds a span to the heightfield.  If the new span overlaps existing spans,
/// it will merge the new span with the existing ones.
///
/// @param[in]	hf					Heightfield to add spans to
/// @param[in]	x					The new span's column cell x index
/// @param[in]	z					The new span's column cell z index
/// @param[in]	min					The new span's minimum cell index
/// @param[in]	max					The new span's maximum cell index
/// @param[in]	areaID				The new span's area type ID
/// @param[in]	flagMergeThreshold	How close two spans maximum extents need to be to merge area type IDs
static bool addSpan(rcHeightfield&amp; hf,
                    const int x, const int z,
                    const unsigned short min, const unsigned short max,
                    const unsigned char areaID, const int flagMergeThreshold)
&#123;
	/// 创建一个Span
	/// 在高度场中找到XZ平面对应的Cell链表头指针
	/// 按照高度从低到高依次遍历已有的Span
	/// 找到链表合适的位置，对于上下重叠的或者小于阈值的临近Span，就合并到新的Span，释放旧Span
	/// 插入新Span
&#125;
</code></pre><h1 id="七-筛选可行走span"><a class="anchor" href="#七-筛选可行走span">#</a> 七、筛选可行走 Span</h1><ul><li>根据 Recast 参数筛选出对应的 Span，并打上对应的 area id 标签。参数：可行走的高度、可攀爬高度...</li><li>参考知乎博主</li></ul><h1 id="八-compactheightfield"><a class="anchor" href="#八-compactheightfield">#</a> 八、CompactHeightfield</h1><h2 id="1-概念-2"><a class="anchor" href="#1-概念-2">#</a> 1. 概念</h2><ul><li>SolidSpan: 不可行走的空间 (Span)。 -&gt; Heightfield<ul><li>Heightfield：高度场中每一个 cell 对象内是一个 span 的链表，span 表示的是玩家不可通过的实心体素。</li></ul></li><li>CompactSpan(Open Span ): <strong>与上面互补</strong>，可行走的空间区域。-&gt; CompactHeightfield<ul><li>CompactHeightfield：紧缩高度场由一个一个 rcCompactSpan 组成。</li><li>rcCompactSpan 的数据结构如下<pre><code class="language-C++">/// Represents a span of unobstructed space within a compact heightfield.
struct rcCompactSpan
&#123;
	/// 底部首个开始的SolidSpan -&gt; Agent寻路的表面
	unsigned short y;				///&lt; The lower extent of the span. (Measured from the heightfield's base.)
	unsigned short reg;			///&lt; The id of the region the span belongs to. (Or zero if not in a region.)
	unsigned int con : 24;		///&lt; Packed neighbor connection data.
	/// CompactSpan的高度，也就是以y开始**连续向上**由多少个**SolidSpan**组成
	unsigned int h : 8;			///&lt; The height of the span.  (Measured from #y.)
&#125;;
</code></pre></li></ul></li><li><strong>注意：前文提到的都是 SolidSpan，后文提到的都是 CompactSpan！</strong></li></ul><h2 id="2-函数和原理"><a class="anchor" href="#2-函数和原理">#</a> 2. 函数和原理</h2><ul><li>rcBuildCompactHeightfield 函数：乾坤颠倒。将 Heightfield 转为 CompactHeightfield，然后释放原来的 Heightfield (后面不会使用了)。</li><li>rcErodeWalkableArea 函数：根据可走行半径参数，标记靠近边界或障碍物的 CompactSpan 为不可走。<ul><li>每个 CompactSpan 的都有一个 Area 属性标记（可走，不可走，草地，雪地，水域...），寻路时每个 agent 有一个 flag 与 area 对应，例如玩家的 flag 包含草地、雪地和水域，那么寻路路径可穿越这些 area，例如怪的 flag 包含草地、雪地，那么寻路时认为水域是阻挡物而绕开。</li><li>Area 可由开发者扩展！</li></ul></li></ul><h1 id="九-创建区域compactregion"><a class="anchor" href="#九-创建区域compactregion">#</a> 九、创建区域 (CompactRegion)</h1><ul><li>区域（region）是一组连续的 span，表示可走表面的范围。</li><li>函数 rcBuildRegions 为每个 CompactSpan 分配一个所属的 Region Id（即：rcCompactSpan::reg）。</li><li>Region 效果图：每块 Region 由不同的颜色区分，黑线代表相邻的 Region 连接可达<br><img data-src="RegionConnection.png" alt="Region Connection"></li></ul><h1 id="十-导航网格三维到二维"><a class="anchor" href="#十-导航网格三维到二维">#</a> 十、导航网格（三维到二维）</h1><h2 id="1-步骤"><a class="anchor" href="#1-步骤">#</a> 1. 步骤</h2><ul><li>取出 Region 轮廓线 Contours<ul><li>函数 rcBuildContours：将 CompactHeightfield 转换为 ContourSet。根据 Span 的 Region 信息提取出<strong>轮廓线</strong>多边形和凸包处理。</li></ul></li><li>根据 Contours 生成导航网格 PloyMesh<ul><li>函数 rcBuildPolyMesh：生成导航导航网格，用于寻路算法！</li></ul></li></ul><h2 id="2-效果图"><a class="anchor" href="#2-效果图">#</a> 2. 效果图</h2><p><img data-src="RawContours.png" alt="Raw Contours"></p><h1 id="下一章寻路"><a class="anchor" href="#下一章寻路">#</a> 下一章：寻路</h1><ul><li>导航网格已经生成 (Region)，后面就是用寻路算法在 Region 上寻路。</li></ul><div class="tags"><a href="/tags/Navigation-Recast/" rel="tag"><i class="ic i-tag"></i> Navigation Recast</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">編集日</span> <time title="修正日：2023-05-13 19:59:15" itemprop="dateModified" datetime="2023-05-13T19:59:15+08:00">2023-05-13</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 寄付</button><p>*~(￣▽￣)~[お茶]を一杯ください</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="XiaoLiang WeChat 支払う"><p>WeChat 支払う</p></div><div><img data-src="/images/alipay.png" alt="XiaoLiang Alipay"><p>Alipay</p></div></div></div><div id="copyright"><ul><li class="author"><strong>著者： </strong>XiaoLiang <i class="ic i-at"><em>@</em></i>打爆你滴脑阔</li><li class="link"><strong>記事へのリンク：</strong> <a href="https://xiaoliangcoder.github.io/Source/Navigation/Recast/" title="Recast">https://xiaoliangcoder.github.io/Source/Navigation/Recast/</a></li><li class="license"><strong>著作権表示： </strong>このブログ内のすべての記事は、特別な記載がない限り <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> の下のライセンスで保護されています。</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/Source/XuanXue/UI/Menu/MenuSystem/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;api.r10086.com&#x2F;img-api.php?type&#x3D;动漫综合3" title="菜单系统系统"><span class="type">前の記事</span> <span class="category"><i class="ic i-flag"></i> MenuSystem</span><h3>菜单系统系统</h3></a></div><div class="item right"><a href="/Source/Navigation/Detour/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;api.dujin.org&#x2F;pic&#x2F;yuanshen&#x2F;" title="無題"><span class="type">次の記事</span> <span class="category"><i class="ic i-flag"></i></span><h3>無題</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="見出し"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">一、简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-recastdemo-uml"><span class="toc-number">2.</span> <span class="toc-text">二、RecastDemo UML</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-%E7%BA%A6%E5%AE%9A%E4%BF%97%E6%88%90"><span class="toc-number">3.</span> <span class="toc-text">三、约定俗成</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B-%E8%BE%93%E5%85%A5%E6%BA%90%E7%8E%AF%E5%A2%83%E7%BD%91%E6%A0%BC"><span class="toc-number">4.</span> <span class="toc-text">四、输入源 (环境网格)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94-recast%E5%8F%82%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">五、Recast 参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD-%E4%BD%93%E7%B4%A0%E5%8C%96"><span class="toc-number">6.</span> <span class="toc-text">六、体素化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">1. 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%88%E6%9E%9C%E5%9B%BE%E7%89%87"><span class="toc-number">6.2.</span> <span class="toc-text">2. 效果图片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%B8%93%E6%9C%89%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="toc-number">6.3.</span> <span class="toc-text">3. 专有名词解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%88%87%E5%89%B2%E5%8E%9F%E7%90%86"><span class="toc-number">6.4.</span> <span class="toc-text">4. 切割原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83-%E7%AD%9B%E9%80%89%E5%8F%AF%E8%A1%8C%E8%B5%B0span"><span class="toc-number">7.</span> <span class="toc-text">七、筛选可行走 Span</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB-compactheightfield"><span class="toc-number">8.</span> <span class="toc-text">八、CompactHeightfield</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5-2"><span class="toc-number">8.1.</span> <span class="toc-text">1. 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-number">8.2.</span> <span class="toc-text">2. 函数和原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D-%E5%88%9B%E5%BB%BA%E5%8C%BA%E5%9F%9Fcompactregion"><span class="toc-number">9.</span> <span class="toc-text">九、创建区域 (CompactRegion)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81-%E5%AF%BC%E8%88%AA%E7%BD%91%E6%A0%BC%E4%B8%89%E7%BB%B4%E5%88%B0%E4%BA%8C%E7%BB%B4"><span class="toc-number">10.</span> <span class="toc-text">十、导航网格（三维到二维）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%AD%A5%E9%AA%A4"><span class="toc-number">10.1.</span> <span class="toc-text">1. 步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%88%E6%9E%9C%E5%9B%BE"><span class="toc-number">10.2.</span> <span class="toc-text">2. 效果图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8B%E4%B8%80%E7%AB%A0%E5%AF%BB%E8%B7%AF"><span class="toc-number">11.</span> <span class="toc-text">下一章：寻路</span></a></li></ol></div><div class="related panel pjax" data-title="関連記事"><ul><li class="active"><a href="/Source/Navigation/Recast/" rel="bookmark" title="Recast">Recast</a></li></ul></div><div class="overview panel" data-title="概要"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="XiaoLiang" data-src="/images/avatar.jpg"><p class="name" itemprop="name">XiaoLiang</p><div class="description" itemprop="description">黑不溜qiu的抠脚大汉</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">17</span> <span class="name">ポスト</span></a></div><div class="item categories"><a href="/categories/"><span class="count">18</span> <span class="name">カテゴリ</span></a></div><div class="item tags"><a href="/tags/"><span class="count">11</span> <span class="name">タグ</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>ホーム</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/Source/XuanXue/UI/Menu/MenuSystem/" rel="prev" title="前の記事"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/Source/Navigation/Detour/" rel="next" title="次の記事"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>ランダムな記事</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/Source/Navigation/Detour/" title="無題">無題</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Navigation/" title="カテゴリ Navigation">Navigation</a> <i class="ic i-angle-right"></i> <a href="/categories/Navigation/Recast/" title="カテゴリ Recast">Recast</a></div><span><a href="/Source/Navigation/Recast/" title="Recast">Recast</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UnrealEngine/" title="カテゴリ UnrealEngine">UnrealEngine</a> <i class="ic i-angle-right"></i> <a href="/categories/UnrealEngine/Editor/" title="カテゴリ Editor">Editor</a> <i class="ic i-angle-right"></i> <a href="/categories/UnrealEngine/Editor/EditorExtend/" title="カテゴリ EditorExtend">EditorExtend</a></div><span><a href="/Source/UnrealEngine/EditorExtend/EditorExtendIntermediate/" title="UE5 编辑器扩展（进阶篇）">UE5 编辑器扩展（进阶篇）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/XuanXue/" title="カテゴリ XuanXue">XuanXue</a> <i class="ic i-angle-right"></i> <a href="/categories/XuanXue/MenuSystem/" title="カテゴリ MenuSystem">MenuSystem</a></div><span><a href="/Source/XuanXue/UI/Menu/MenuSystem/" title="菜单系统系统">菜单系统系统</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UnrealEngine/" title="カテゴリ UnrealEngine">UnrealEngine</a> <i class="ic i-angle-right"></i> <a href="/categories/UnrealEngine/AutomationTest/" title="カテゴリ AutomationTest">AutomationTest</a></div><span><a href="/Source/UnrealEngine/AutomationTest/AutomationTest/" title="UE5 自动化测测试">UE5 自动化测测试</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UnrealEngine/" title="カテゴリ UnrealEngine">UnrealEngine</a> <i class="ic i-angle-right"></i> <a href="/categories/UnrealEngine/Editor/" title="カテゴリ Editor">Editor</a> <i class="ic i-angle-right"></i> <a href="/categories/UnrealEngine/Editor/EditorExtend/" title="カテゴリ EditorExtend">EditorExtend</a></div><span><a href="/Source/UnrealEngine/EditorExtend/EditorExtendMenuSource/" title="UE5 编辑器扩展（源码篇）">UE5 编辑器扩展（源码篇）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UnrealEngine/" title="カテゴリ UnrealEngine">UnrealEngine</a> <i class="ic i-angle-right"></i> <a href="/categories/UnrealEngine/Input/" title="カテゴリ Input">Input</a></div><span><a href="/Source/UnrealEngine/Input/InputFramework/" title="UE5 输入系统">UE5 输入系统</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UnrealEngine/" title="カテゴリ UnrealEngine">UnrealEngine</a> <i class="ic i-angle-right"></i> <a href="/categories/UnrealEngine/Editor/" title="カテゴリ Editor">Editor</a> <i class="ic i-angle-right"></i> <a href="/categories/UnrealEngine/Editor/EditorExtend/" title="カテゴリ EditorExtend">EditorExtend</a></div><span><a href="/Source/UnrealEngine/EditorExtend/EditorExtendSample/" title="UE5 编辑器扩展（实战篇）">UE5 编辑器扩展（实战篇）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/UnrealEngine/" title="カテゴリ UnrealEngine">UnrealEngine</a> <i class="ic i-angle-right"></i> <a href="/categories/UnrealEngine/Editor/" title="カテゴリ Editor">Editor</a> <i class="ic i-angle-right"></i> <a href="/categories/UnrealEngine/Editor/EditorExtend/" title="カテゴリ EditorExtend">EditorExtend</a></div><span><a href="/Source/UnrealEngine/EditorExtend/EditorExtendPrimary/" title="UE5 编辑器扩展（入门篇）">UE5 编辑器扩展（入门篇）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/XuanXue/" title="カテゴリ XuanXue">XuanXue</a> <i class="ic i-angle-right"></i> <a href="/categories/XuanXue/GameFlowSystem/" title="カテゴリ GameFlowSystem">GameFlowSystem</a></div><span><a href="/Source/XuanXue/GameFlowSystem/GameFlowSystem/" title="游戏流程系统">游戏流程系统</a></span></li></ul></div><div><h2>最近のコメント</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2022 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">XiaoLiang @ Senior Brother</span></div><div class="powered-by">Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"Source/Navigation/Recast/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"検索…",empty:"「 ${query} 」については何も見つかりませんでした",stats:"${time} ms以内に ${hits} 件の結果が見つかりました"},valine:!0,fancybox:!0,copyright:"コピーは成功しました。 <br> 再印刷については、 ％s 契約に従ってください。",ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->